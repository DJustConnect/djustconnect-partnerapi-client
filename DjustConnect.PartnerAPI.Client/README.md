# DjustConnect PartnerAPIClient## Consumerclient  The sample code in the ConsumerClient addresses the DjustConnect partnerAPI from a data-consumer perspective.Following paragraphs illustrate how to set-up the client, how to talk to the api's endpoints and how to process the responses.  **Choose appropriate constructor**  Talking to the partnerapi requires a client certificate to be presented at any request. Depending on your workflow, this consumerclient offers the following HttpClient-options:  **Consumerclient with your ready-made Httpclient**      <pre><code>        public ConsumerClient(HttpClient httpClient) : base(httpClient)        {        } </code></pre>**Consumerclient with HttpClient presenting a certificate from your Local Machine's personal certificate store**      <pre><code>        public ConsumerClient(string thumbprint, string subscriptionkey)        {            _httpClient = Client.GetHttpClientWithLocalCertificate(thumbprint, subscriptionkey);        }         public static HttpClient GetHttpClientWithLocalCertificate(string thumbprint, string subscriptionkey)        {            var certificate = GetCertificateFromLocalCertStore(thumbprint);            return GetHttpClient(certificate, subscriptionkey);        }        private static X509Certificate2 GetCertificateFromLocalCertStore(string thumbprint)        {            var store = new X509Store("My", StoreLocation.LocalMachine);            store.Open(OpenFlags.ReadOnly);            var certificates = store.Certificates.Find(X509FindType.FindByThumbprint, thumbprint, false);            if (certificates.Count == 0)            {                throw new InvalidOperationException($"Certificate not found in LocalMachine/My.");            }            return certificates[0];        }        </code></pre>**Consumerclient with HttpClient presenting a certificate from your Azure key vault**    <pre><code>        public ConsumerClient(string thumbprint, string subscriptionkey, string keyvaultname, string tenantId, string certSecretname)        {            _httpClient = Client.GetHttpClientWithAzureKeyvaultCertificate(thumbprint, subscriptionkey, keyvaultname, tenantId, certSecretname);        }                public static HttpClient GetHttpClientWithAzureKeyvaultCertificate(string thumbprint, string subscriptionkey, string keyvaultname, string tenantId, string certSecretname)        {            var certificate = GetCertificateFromKeyVault(thumbprint, keyvaultname, tenantId, certSecretname);            return GetHttpClient(certificate, subscriptionkey);        }                private static X509Certificate2 GetCertificateFromKeyVault(string thumbprint, string keyvaultname, string tenantId, string certSecretname)        {            var ascs = new AzureSecretClientService(keyvaultname,tenantId);            return ascs.GetClientCertificateFromKeyVault(certSecretname);        }                public AzureSecretClientService(string keyvaultname, string tenantId)        {            DefaultAzureCredentialOptions options = new DefaultAzureCredentialOptions()            {                SharedTokenCacheTenantId = tenantId,                VisualStudioTenantId = tenantId            };            _client = new SecretClient(new Uri($"https://{keyvaultname}.vault.azure.net/"),                                        new DefaultAzureCredential(options));        }        public X509Certificate2 GetClientCertificateFromKeyVault(string secretname)        {            // Get full certificate + private key object from keyvault with secretclient            // see --> https://github.com/Azure/azure-sdk-for-js/issues/7647            var PKCS12 = _client.GetSecret(secretname).Value;            var PKCS12bytes = Convert.FromBase64String(PKCS12.Value);            //specify StorageFlags, otherwise WindowsCryptographicException when deploying to Azure            return new X509Certificate2(                PKCS12bytes,                String.Empty, // omit pw                X509KeyStorageFlags.MachineKeySet |                X509KeyStorageFlags.PersistKeySet |                X509KeyStorageFlags.Exportable);        }  </code></pre>* **Abstractions**  Except for one endpoint (FarmMapping, see further) GET and POST calls are all redirected to the same generic methods.   	- **GET**  		A typical GET call will have the following structure:  <pre><code>        public Task&lt;EndpointDTO> GetEndpointAsync()        {            return GetEndpointAsync(CancellationToken.None);        }        public async Task&lt;EndpointDTO> GetEndpointAsync(CancellationToken cancellationToken)        {            var urlBuilder_ = new StringBuilder();            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/Endpoint?");            return await CallAPI(urlBuilder_, GetResult&lt;EndpointDTO>, cancellationToken);        }  </code></pre>	- **GetResult&lt;T¨>**  		Generic method for deserializing json to a desired DTO.  <pre><code>		public static T GetResult&lt;T>(Dictionary&lt;string, IEnumerable&lt;string>> headers, string json)		{			return Newtonsoft.Json.JsonConvert.DeserializeObject&lt;T>(json);		}</code></pre>	- **CallAPI**  * **Endpoints**:  The partnerAPI's endpoints are described in the open spec documentation at "https://partnerapi.djustconnect.be/index.html".   The ConsumerClient provides methods to make the partnerAPI easily accessible, leaving you with the remaining care only to formulate the request properly.  Following bulletpoints walk you through the various endpoints and their specific requirements:  	- **api/farmer (GetFarmsAsync) (GET)**  	returns array of KBO numbers associated with AzureAdb2c userId  		+ params: AzureAdB2CUserId = the unique IDentifier returned to you on succeeded login via the djustconnect AzureAdB2C openID-login 		+ response: string[] of KBO-numbers associated with this unique identifier.	- **api/farmmapping (GetFarmMappingAsync) (GET)**  	Returns a mapping of associated IDs for every requested (farm)ID. This GET method <span style="color:purple;">does not take query parameters but the exceptional requestbody</span> parameters.  	Typically you'd call this endpoint after acquiring the array of KBO numbers associated with your AADB2C login and pass this array into the 	FarmMapping endpoint requestbody's requestIDs property. But any type of identifier can in fact be used, as long as it is known in DjustConnect and you provide 	the correct farmIdType (these are listed next to the responseID's property underneath). Briefly, any input ID can be mapped to one or more of these output id's.		+ params: no		+ requestbody: FarmMappingDTO			* requestIDs: the farmIds for which mappings are requested  			* responseIds: specify the Id's to be included in response  				KBO: 4c17a3f2-c03d-4d65-8440-3a896b245753				Beslag nummer: 324a23eb-b4bc-4de1-a01b-0e478afac252				Keuring Spuittoestellen: dd03e71c-d114-4cce-a5fe-6843f1fc8878				PE nummer: d55fe787-6ea0-46e8-9f00-d9e5e86bad2b			* farmIdType: specifies the type (cfr responseIds) of the ID used as requestId, e.g. if KBO then farmIdType = "4c17a3f2-c03d-4d65-8440-3a896b245753"		+ response: FarmMappingResultDTO	- **api/consumeraccess (GET, POST)**   		+ GET: get your ConsumerAccess			* params: no			* response: ConsumerAccessDTO		+ POST: create/update your ConsumerAccess.  			* params: no  			* requestbody: ConsumerAccessDTO  			* response: HttpStatusCode   			To update, first GET ConsumeraccessDTO apply changes, then POST same (updated) DTO in requestbody  	- **api/farmidtype (GET)**  		+ params: no  		+ response: all farmIdTypes (farmIdTypeDTO)	- **api/resource (GET)**   		+ params: no  		+ response: all resources (ResourceDTO)  	- **api/rarstatus (GET)** - Returns the statuses of your Resource Access Requests  		+ params: resourceNameFilter[, StatusFilter, apiNameFilter, ProviderNAmeFilter, PageNumber, PageSize, Sort]  		+ response: RarStatusDTO  	- **api/darStatus (GET)** - Returns the current status of your Data Access Requests  		+ params: FarmNumberFilter[, ResourceNameFilter, ResourceIdFilter, FarmstatusFilter, DarStatusFilter, PageNumber, PageSize, Sort]    		+ response: DarStatusDTO  	- **api/farmstatus (GET)**  		+ params: farmnumberfilter("no" filter, get all farms and their statuses) || FarmStatusFilter (filter farms on specified status)		+ response: FarmstatusDTO (farmnumber, Status (HasUser, NotFound, HasNoUser))  	- **api/consumer/resource-health (GET)**  		+ params: string resourcetypeID  		+ response: resourceHealth object for requested resource (ResourceHealthDTO)  	- **api/Consumer/push (GET)**  -get your consumer notification endpoint details		+ params: no		+ response: NotificationResultDTO  	- **api/Consumer/push/activate (POST)** -activate your pushnotifications endpoint		+ params: no		+ requestbody: string(endpoint)		+ response: statuscode(200 - OK,400 - endpoint not valid ,403 - not a consumer)  	- **api/Consumer/push/deactivate (POST)** -deactivate your pushnotifications endpoint		+ params: no		+ requestbody: string(endpoint)		+ response: statuscode(200 - OK, 403 - not a consumer)	